package bn.blaszczyk.rose.creators;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.List;

import bn.blaszczyk.rose.MetaData;
import bn.blaszczyk.rose.RoseException;
import bn.blaszczyk.rose.model.*;

public class SQLCreator {
	
	public static void create(final List<EntityModel> entities, final MetaData metadata, final String parentDir) throws RoseException
	{
		final String fullpath = getFullPath(metadata, parentDir);
		final File file = new File(fullpath);
		if(!file.getParentFile().exists())
			file.getParentFile().mkdirs();
		try(final FileWriter writer = new FileWriter(file))
		{
			writer.write("--" + getFileName(metadata) + "\r\n"
					+ "--generated by rose");
			
			writer.write("\r\n\r\n"
					+ "--drop tables\r\n\r\n");
			for(int i = entities.size() - 1; i >= 0; i-- )
			{
				writer.write("drop table " + getTableName(entities.get(i)) + ";\r\n");
			}
			writer.write("\r\n\r\n"
					+ "--create tables\r\n");
			for(EntityModel entity : entities)
			{
				createTable(entity, metadata, writer);
				for(EntityField entityField : entity.getEntityFields() )
					if( needsManyToManyTable(entityField) )
						createManyToManyTable(entityField, writer);
			}
			writer.write("\r\n\r\n"
					+ "--create indices\r\n");
			for(final EntityModel entityModel : entities)
			{
				for(final EntityField field : entityModel.getEntityFields())
				{
					if(hasColumn(field))
						createIndex(field, writer);
					if(needsManyToManyTable(field))
						createManyToManyIndices(field,writer);
				}
			}
			System.out.println( "File created: " + fullpath);
		}
		catch (IOException e)
		{
			throw new RoseException("error creating sql script", e);
		}
	}
	
	private static String getFileName(final MetaData metadata)
	{
		return metadata.getDbname() + ".sql";
	}

	private static String getFullPath(final MetaData metadata, final String parentDir) {
		final String fullpath = parentDir + "/" + metadata.getSqlpath() + getFileName(metadata);
		return fullpath;
	}
	
	public static String getManyToManyTableName( EntityField field  )
	{
		String format = "%s_%s";
		if(needsManyToManyTable(field))
			return String.format(format, field.getName(), field.getCounterName());
		else
			return String.format(format, field.getCounterName(), field.getName());
	}

	public static void createManyToManyTable( EntityField field, Writer writer ) throws IOException
	{
		writer.write("\r\ncreate table " + getManyToManyTableName(field) + "\r\n"
			+ "(\r\n"
			+ "\t" + field.getName() + "_id int,\r\n"
			+ "\t" + field.getCounterName() + "_id int\r\n"
			+ "\tconstraint pk_" + getManyToManyTableName(field) + " primary key ( " + field.getName() + "_id, " + field.getCounterName() +"_id )\r\n"
			+ ");\r\n");
	}

	public static boolean needsManyToManyTable(EntityField field)
	{
		return field.getType() == RelationType.MANYTOMANY && ( field.getEntityName().compareTo(field.getCouterpart().getEntityName()) < 0 );
	}
	
	public static void createTable(EntityModel entity, MetaData metadata, Writer writer) throws IOException
	{
		// create table
		writer.write( "\r\ncreate table " + getTableName(entity) + "\r\n"
				+ "(\r\n" );
		
		// primary column
		writer.write("\t" + entity.getObjectName() + "_id int");
		switch(DBType.getType(metadata.getDbtype()))
		{
		case MYSQL:
			writer.write( " auto_increment,\r\n");
			break;
		}
		// primitive and enum columns
		for(Field field : entity.getFields())
			writer.write( "\t" + field.getName() + " " + field.getSqlType() + ",\r\n");
		
		// relational columns
		for(EntityField entityField : entity.getEntityFields())
			if(hasColumn(entityField))
				writer.write( "\t" + entityField.getName() + "_id int,\r\n" );
		
		// timestamp
		if(metadata.isUsingTimestamp())
			writer.write("\ttimestamp_update timestamp default current_timestamp on update current_timestamp,\r\n");
		// primary key
		writer.write( "\tconstraint pk_" + entity.getSimpleClassName().toLowerCase() + " primary key ( " + entity.getObjectName() + "_id )");
		
		//foreign keys
		if(metadata.isUsingForeignKeys())
			for(EntityField entityField : entity.getEntityFields())
				if(entityField.getType() == RelationType.MANYTOONE)
					writer.write( ",\r\n\tconstraint fk_" + entity.getSimpleClassName().toLowerCase() + "_" + entityField.getEntityModel().getSimpleClassName().toLowerCase()
								+ " foreign key ( " + entityField.getName() + "_id ) references "
								+ entityField.getEntityModel().getSimpleClassName() + "( " + entityField.getEntityModel().getObjectName() + "_id )");
		//fin
		writer.write( "\r\n"
				+ ");\r\n" );
	}

	private static String getTableName(EntityModel entity) {
		return entity.getObjectName().toLowerCase();
	}

	public static void createIndex(final EntityField field, final Writer writer) throws IOException {
		final EntityModel entity = field.getCouterpart().getEntityModel();
		writer.write("\r\ncreate index " + getTableName(entity) + "_" + field.getName() + "\r\n"
				+ "on " + getTableName(entity) + " ( " + field.getName() + "_id );\r\n");
	}

	public static void createManyToManyIndices(final EntityField field, final Writer writer) throws IOException {
		writer.write("\r\ncreate index " + getManyToManyTableName(field) + "_" + field.getName() + "\r\n"
				+ "on " + getManyToManyTableName(field) + " ( " + field.getName() + "_id );\r\n");
		writer.write("\r\ncreate index " + getManyToManyTableName(field) + "_" + field.getCounterName() + "\r\n"
				+ "on " + getManyToManyTableName(field) + " ( " + field.getCounterName() + "_id );\r\n");
	}

	public static void clear(final MetaData metadata, final String parentDir)
	{
		final String fullPath = getFullPath(metadata, parentDir);
		final File file = new File(fullPath);
		if(file.exists())
			file.delete();
	}
	
	public static boolean hasColumn(EntityField entityField) {
		return entityField.getType() == RelationType.MANYTOONE 
			 || ( entityField.getType() == RelationType.ONETOONE  &&  entityField.getName().compareTo(entityField.getCounterName()) < 0 );
	}
}


