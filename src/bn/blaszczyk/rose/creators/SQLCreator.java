package bn.blaszczyk.rose.creators;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.List;

import bn.blaszczyk.rose.MetaData;
import bn.blaszczyk.rose.RoseException;
import bn.blaszczyk.rose.model.*;

public class SQLCreator {
	
	public static void create(List<EntityModel> entities, MetaData metadata) throws RoseException
	{
		String fullpath = metadata.getSqlpath() + "createtables.sql";
		File file = new File(fullpath);
		if(!file.getParentFile().exists())
			file.getParentFile().mkdirs();
		try(FileWriter writer = new FileWriter(file))
		{
			writer.write("--createtables.sql\r\n"
					+ "--generated by rose\r\n\r\n");
			
			for(int i = entities.size() - 1; i >= 0; i-- )
			{
				writer.write("drop table " + entities.get(i).getSimpleClassName() + ";\r\n");
			}
			for(EntityModel entity : entities)
			{
				createTable(entity, metadata, writer);
				for(EntityField entityField : entity.getEntityFields() )
					createManyToManyTable(entityField, writer);
			}
			System.out.println( "File created: " + fullpath);
		}
		catch (IOException e)
		{
			throw new RoseException("error creating sql script", e);
		}
	}
	
	public static String getManyToManyTableName( EntityField field  )
	{
		String format = "%s_%s";
		if( field.getName().compareTo(field.getCounterName()) < 0)
			return String.format(format, field.getCapitalName(), field.getCounterCapitalName());
		else
			return String.format(format, field.getCounterCapitalName(), field.getCapitalName());
	}

	private static void createManyToManyTable( EntityField field, Writer writer ) throws IOException
	{
		if( field.getType() == RelationType.MANYTOMANY && ( field.getName().compareTo(field.getCounterName()) < 0 ) )
			writer.write("create table " + getManyToManyTableName(field) + "\r\n"
					+ "(\r\n"
					+ "\t" + field.getName() + "_id int,\r\n"
					+ "\t" + field.getCounterName() + "_id int\r\n"
					+ ");\r\n\r\n"   );
	}
	
	public static void createTable(EntityModel entity, MetaData metadata, Writer writer) throws RoseException
	{
		try
		{
			// create table
			writer.write( "\r\ncreate table " + entity.getObjectName().toLowerCase() + "\r\n"
					+ "(\r\n" );
			
			// primary column
			writer.write("\t" + entity.getObjectName() + "_id int");
			switch(DBType.getType(metadata.getDbtype()))
			{
			case MYSQL:
				writer.write( " auto_increment,\r\n");
				break;
			}
			// primitive and enum columns
			for(Field field : entity.getFields())
				writer.write( "\t" + field.getName() + " " + field.getSqlType() + ",\r\n");
			
			// relational columns
			for(EntityField entityField : entity.getEntityFields())
				if(entityField.getType() == RelationType.MANYTOONE 
					 || ( entityField.getType() == RelationType.ONETOONE  &&  entityField.getName().compareTo(entityField.getCounterName()) < 0 ))
					writer.write( "\t" + entityField.getName() + "_id int,\r\n" );
			
			// timestamp
			if(metadata.isUsingTimestamp())
				writer.write("\ttimestamp_update timestamp default current_timestamp on update current_timestamp,\r\n");
			// primary key
			writer.write( "\tconstraint pk_" + entity.getSimpleClassName().toLowerCase() + " primary key ( " + entity.getObjectName() + "_id )");
			
			//foreign keys
			if(metadata.isUsingForeignKeys())
				for(EntityField entityField : entity.getEntityFields())
					if(entityField.getType() == RelationType.MANYTOONE)
						writer.write( ",\r\n\tconstraint fk_" + entity.getSimpleClassName().toLowerCase() + "_" + entityField.getEntityModel().getSimpleClassName().toLowerCase()
									+ " foreign key ( " + entityField.getName() + "_id ) references "
									+ entityField.getEntityModel().getSimpleClassName() + "( " + entityField.getEntityModel().getObjectName() + "_id )");
			//fin
			writer.write( "\r\n"
					+ ");\r\n" );
		}
		catch(IOException e)
		{
			throw new RoseException("error writing table create", e);			
		}
	}
}


